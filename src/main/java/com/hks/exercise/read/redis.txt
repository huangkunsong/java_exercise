redis优点：
  所有数据保存在内存中,响应速度快
  非阻塞IO,使用epoll作为I/O多路复用技术的实现
  单线程避免了线程切换和竞态产生的消耗。
redis缺点：
  单线程导致：某个命令执行过长，会造成其他命令的阻塞。


redis-server /configPath
redis-server stop 停止
redis-server start 启动
redis-server restart 重启

redis-cli -h host -p port -a password
redis-cli [-h -p] -showdown [save|nosave] 停止redis,生成持久化文件

redis key 命令规范：
业务场景名:对象名:id[属性]，适当减少key长度,避免内存浪费,加快获取


=====================================================================================
全局命令
keys * 查询所有key,支持pattern匹配。复杂度：O(n)
dbsize 查看key总数,不会遍历所有key,直接取内部变量。复杂度：O(1)
exists key1 [key2] 检查键是否存在,支持查询多个,返回存在的个数
del key [key] 删除key，返回成功删除的个数,不存在返回0
expire key 10 设置key的过期时间,单位s
ttl key 返回key的过期时间,-1：未设置过期时间,-2：key不存在
type key 获取key的数据结构,key不存在返回none
object encoding key 查看key的内部编码

数据结构                  内部编码（默认大小可以调整）
string(字节长度)          int(8),embstr(小于39),raw(大于39)
hash(field个数)           ziplist(field小于512个,所有value小于64bit),hashtable(消耗更多内存)
list(值个数)              老版本：ziplist(值个数小于512个且所有值小于64bit),
                         老版本：linkedlist(内部每个value需要维护prev和next指针且每个元素内存单独分配,增加内存碎片)
                         3.2版本后都使用
                         quicklist
                            (ziplist和linkedlist混合,将linkedlist分段保存,每段保存一个ziplist)
                            (多个ziplist用prev和next指针相连,每个ziplist默认存储8kb数据)
                            (通过list-max-ziplist-size设置每个ziplist存储大小,正数按个数存储,负数按kb存储)
                            (通过list-compress-depth,设置压缩深度,0表示不压缩(默认) 1表示2端各有一个节点不压缩,中间的都压缩)

set       hashtable,intset
zset(有序集合)      skiplist,ziplist
Bitmaps（位图）
HyperLogLog、GEO（地理信息定位）

=====================================================================================
字符串（最大不能超过512MB）操作：
set key value [ex seconds] [px milliseconds] [nx | xx] 添加key，失败返回(nil)
  ex 设置秒过期时间
  px 设置毫秒过期时间
  nx key必须不存在才可以设置,做更新动作
  xx key必须存在才可以设置
setex key seconds value  和 xx左右一致
setnx key value 和nx作用一致.
  setex,setnx 可以作为分布式锁的一种实现方案
get key 获取值
mset key value [key value] 批量设置值
mget key [key] 批量按顺序获取值,不存在的key值为(nil)
  mset,mget减少多次网络请求及等待处理时间,提高效率

incr key 自增1,返回自增后的值,key不存时,按照值为0开始自增,返回1。key不是整型报错。
decr key 自减,规则同incr
incrby key value 自增指定数值
decrby key value 自减指定数值
incrbyflaot 自增指定浮点数(不准确)
append key value 对指定key的值进行追加,返回value长度。key不存在为新增
strlen key 返回指定key的value值长度
getset key value 设置并返回旧值
setrange key offeset value  设置指定位置字符串
getrange key start end 获取部分字符串

字符串使用场景：
    缓存功能
    计算功能：如,点赞数量
    共享session
    限速：如限制操作指定时间内的次数
      key = "shortMsg:limit:" + phoneNum;
      isExists = redis.set(key,1,"EX 60","NX");
      if(isExists != null || redis.incr(key) <=5){通过} else {限制}

=====================================================================================
Hash
hset key field value 设置hash键值对
  hset user:1 name rookie
  hset user:1 age 10
hsetnx key field value 指定field不存在时设置,成功返回1,失败返回0
hget key field 获取值,不存在返回(nil)
hdel key field [field] 删除指定field
hmset key field value [field value] 批量设置
hmget key field [field] 批量获取
hexists key field 判断指定field是否存在
hkeys key  获取所有field
hvals key  获取所有value
hgetall key 获取所有field-value
hincryby key field value 对指定field自增指定数值
hincrbyfloat 同上,不准
hstrlen key field 获取指定field长度

使用场景：
  存储对象数据，比存储json串的string类型使用方便

=====================================================================================
List（一个列表最多存储2^32-1,与JS一致）
lpush key value [value] 左边插入,插入多个时为倒叙,成功返回list长度
rpush key value [value] 右边插入
linsert key before|after item value 在指定元素item之前或之后插入元素,
                                    从list左边开始查询item,以第一个找到的为准
                                    成功返回list长度,失败返回-1
lpop key  左边删除,返回删除的元素
rpop key  右边删除
lindex key index 获取指定下标的值,支持负数查询
lrange key startIndex endIndex 获取元素下标startIndex到endIndex元素（包含endIndex）
                                以0开始,-1为最后一个元素,-2为倒数第二
llen key 查询list长度
lset key index value 修改指定下标的值
lrem key count value 从列表中找到等于value的元素进行删除,count指定删除个数和方向
  count > 0 从左到右删除count个等于value的元素
  count < 0 从右到左删除count个等于value的元素
  count = 0 删除所有等于value的元素
  返回删除的个数
ltrim key startIndex endIndex 对列表进行裁剪
  ltrim list 2 5  保留下标2到5的元素
blpop/brpop key [key] tiemout
   阻塞删除,如果list中存在指定元素则直接删除,并返回删除的元素
   如果list为空则等待timeout时间(单位s),等待list中有元素后删除返回
   超过timeout时间则返回(nil),timeout=0 为一直等待
   只会阻塞当前客户端,不会阻塞其他命令执行
   多个客户端对同个key执行阻塞删除时,按顺序释放
   实现消息队列的基本。

使用场景：
  lpush+lpop=Stack（栈）
  lpush+rpop=Queue（队列）
  lpsh+ltrim=Capped Collection（有限集合）
  lpush+brpop=Message Queue（消息队列）
  存储列表数据,分页查询等

=====================================================================================
Set