运行时数据区：
    java虚拟机在运行时会将内存空间划分为不同的数据区域。
    每个区域都有各自的用途以及生命周期。
    有些区域伴随着JVM进程的存在而存在，有些区域“随线程而生，随线程而死”。
    堆和方法区为JVM生命周期。
    栈,寄存器（程序计数器）,本地方法栈。为线程生命周期。
--------------------------------------------------------------------
堆：
    用来存储Java中的对象。
    无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
    该区所有对象被gc（自动内存管理系统）管理,不需要也无法显示销毁。
    jvm只有一个heap区，被所有线程共享，不存放基本类型和对象引用，只存放对象本身。
    堆内存没有可用的空间存储生成的对象时，
    JVM会抛出java.lang.OutOfMemoryError,无法用try/catch捕获。
    堆大小 = 年轻代 + 老年代
        年轻代：特点是产生大量的死亡对象,并且要是产生连续可用的空间,
                所以使用复制清除算法和并行收集器进行垃圾回收.
                对年轻代的垃圾回收称作初级回收 (minor gc)
            年轻代 = 新生代  + 2个复活代
栈（虚拟机栈）:
    每一个线程包含一个stack区，只保存基本数据类型的对象和自定义对象的引用。
    每个栈中的数据（基本数据类型和对象引用）都是私有的，其他栈不能访问；
    栈内容超过容量时（1M）,报：StackOverflowError
    新建时无内存创建对应对应的栈时,报：OutOfMemoryError
    如果方法调用的栈深度大于虚拟机允许的最大栈深度，就会出现stackOverFlow异常。
    递归方法调用时，如果调用栈过深，就有可能引发栈溢出。
    栈由一个个的栈帧组成。
    栈帧：
        当调用一个Java方法时,JVM压入一个新的栈帧到该线程的虚拟机栈中；
        当方法返回时，这个栈帧被从虚拟机栈中弹出并抛弃。
        局部变量区:
            被组织为一个数组,该数组单个元素长度为一个JVM字（注意不是一个机器字）,
            用于保存位于方法内的局部变量数据。
        操作数栈:
        动态链接：
        方法返回地址

方法区：
     又叫静态区，跟堆一样，被所有的线程共享。
     方法区中包含的都是在程序中永远的唯一的元素.
     存放了每一个类的结构信息：
        字段,方法数据,常量,静态变量、构造函数,和普通方法的字节码。
     内存不足时,抛出OutOfMemoryError异常。
     运行时常量池：
        每一个类或接口都有对应的运行时常量池,是Class文件中的一部分。
        存储了类、方法、接口等中的常量，当然也包括字符串常量。

寄存器（程序计数器）：每一个线程创建时创建。
        JVM多线程是通过轮流切换并分配CPU时间的,在任何一个时刻,
        一个线程只会执行一个方法的代码,称为线程的当前方法。
        如果方法不是native的,寄存器保存Java虚拟机正在执行的字节码指令的地址。
        如果方法是nvtive的,寄存器存放undefined
        为了保证每条线程切换后恢复到正确的位置,每个线程都需要一个独立的程序计数器。
本地方法栈：
    线程创建时创建。存放native方法信息。
---------------------------------------------------------------------
Java 中的堆也是 GC 收集垃圾的主要区域。
GC 分为两种：
    Minor GC（初级回收）：是发生在新生代中的垃圾收集动作，所采用的是复制算法。
        初级回收将年轻代分为三个区域, 一个新生代 , 一个激活复活代,一个空闲复活代。（2个复活代大小一致）
        应用程序只能使用一个新生代和一个激活复活代。
        新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。
        Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。
        当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。
        新生代是 GC 收集垃圾的频繁区域。
        当对象在新生代出生后，在经过一次初级回收后，如果对象还存活，并且能够被另外一块
        激活复活代区域所容纳，则使用复制算法将这些新生代和激活状态复活代中仍然还存活的对象复制到空闲复活代中，
        然后清理新生代以及激活复活代，在将空闲复活代变为激活复活代,原激活复活代变为空闲复活代。
        以后对象在复活代区每熬过一次初级回收，就将对象的年龄 + 1，
        当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，
        这些对象就会成为老年代。
        但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
    Full GC (或称为 Major GC)： 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。
        Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。
        另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，
        再需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。
        System.gc();手动进行老年代垃圾清理。
---------------------------------------------------------------------
JVM启动参数：
    -Xms：设置堆启动大小，默认是物理内存的1/64
    -Xmx：设置堆最大值，默认是物理内存的1/4
    -XX:PermSize=64M JVM初始分配的永久代大小(1.8后为元空间)，默认是物理内存的1/64
    -XX:MaxPermSize=128M JVM最大允许分配的非堆内存，默认是物理内存的1/4
    -Xss：设置线程堆栈大小,默认1M
    -XX:MetaspaceSize  设置元空间启动内存(JDK8才有，取缔持久代)
    -XX:MaxMetaspaceSize  设置元空间最大内存(JDK8才有，取缔持久代)
    -Xmn：设置年轻代大小
    -XX:NewRatio  新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3
    -XX:MaxTenuringThreshold  设置新生代经过N次回收后转为老年代,默认15
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；
空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。
因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。
------------------------------------------------------------------
JVM可支持最大线程数：
    无内存创建线程时,会报：
        java.lang.OutOfMemoryError: unable to create new native thread
    最大线程数公式：
         (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)
         MaxProcessMemory ：
            一个进程可以使用的最大内存。
            32位的 windows下是 2G
            64位的 windows下是 无限制？
            32位的 Linux 下是2G
            64位的 Linux 下是3G
         JVMMemory：
            堆最大大小+方法区最大大小
         ReservedOsMemory：
             保留的操作系统内存一般是130M左右,不确定大小
         ThreadStackSize：
            线程大小： -Xss：设置线程堆栈大小,默认1M
    JVMMemory分配越大,可创线程越少。
