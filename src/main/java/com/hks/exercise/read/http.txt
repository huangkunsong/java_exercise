HTTP(超文本传输协议),处于计算机网络中的应用层,HTTP是建立在TCP（传输层）协议之上,
所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性。
HTTP协议是建立在TCP之上的,所以有TCP建立连接的3次握手和断开连接的4次挥手

TCP协议6种标识：
    SYN：synchronous(建立连接)
    ACK：acknowledgement(确认)
    PSH：push(传送数据)
    FIN：finish(结束)
    RST：rest(重置)
    URG: urgent(紧急)
TCP协议2个顺序号码,每个数据包都有
    Sequence number(顺序号码,Seq)
    Acknowledge number(确认号码,ACK)

TCP连接3次握手：
    第一次握手：主机A发送：SYN = 1,Seq = X 数据包到主机B,主机B由SYN=1知道主机A要建立连接。
    第二次握手：主机B发送：SYN = 1,ACK = X+1, Seq = Y 数据包给主机A。
    第三次握手：主机A发送：ACK = Y+1, Seq = Z

TCP断开连接4次挥手：
    第一次挥手：主动方发送：FIN = 1, ACK = Z, Seq = X 数据包到被动方(Z,X为之前请求数据的Seq和ACK决定)
    第二次挥手：被动方发送：ACK = X + 1, Seq = Z (告诉主动方收到断开连接请求,准备断开连接进入半断开状态：不直接断开连接是有的数据还在传输中,这时不会再接收新的请求数据)
    第三次挥手：被动方发送：FIN = 1, ACK = X, Seq = Y(告诉主动方数据都同步完了,可以断开连接了)
    第四次挥手：主动方发送：ACK = Y, Seq = X (告诉被动方,主动方断开了,收到被动方的FIN数据包后会等待2 * MSL(报文最大生存时间))

HTTP 1.0 和 HTTP 1.1区别：
    1：缓存处理：
        HTTP1.0：
            主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准,
        HTTP1.1：
            则引入了更多的缓存控制策略
            Entity tag,If-Unmodified-Since, If-Match, If-None-Match
    2：带宽优化及网络连接的使用：
        HTTP1.1:
            在请求头引入了range头域,它允许只请求资源的某个部分,
            即返回码是206(Partial Content),这样就方便了开发者自由的选择以便于充分利用带宽和连接。
    3：错误通知的管理：
        HTTP1.1中新增了24个错误状态响应码
    4：Host头处理：
        HTTP1.0：
            认为每台服务器都绑定一个唯一的IP地址,因此,请求消息中的URL并没有传递主机名（hostname）。
        HTTP1.1：
            但随着虚拟主机技术的发展,在一台物理服务器上可以存在多个虚拟主机,并且它们共享一个IP地址。
            请求消息和响应消息都应支持Host头域,且请求消息中如果没有Host头域会报告一个错误400.
    5：长连接:
        HTTP 1.0：
            连接无法复用导致每次都经历三次握手和慢启动。
            下个请求要等上个请求返回后才能发出。
        HTTP 1.1：
            1：支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理.
               默认开启Connection： keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
               Connection: keep-alive
               Keep-Alive: timeout=5, max=100（表示链接保存5S，最多100个请求）
               Connection: close  关闭长链接
            2：在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟,
               浏览器会有单域名最大连接数限制(大约8个,不同浏览器不同),所以类似TB这样大量图片都有不同域名加载。
基于HTTP1.1请求优化：
    1：压缩内容,将多个JS,html,css进行压缩和文件合并
    2：合并小图,使用雪碧图
    3：使用多个域名提高并发请求量
    4：使用缓存

HTTP1.1缺点：
    协议开销大：header里携带的内容过大,尤其是cookie,每次请求header基本不怎么变,增加用户流量。
    安全因素：传输的内容都是明文。

HTTP2.0基于SPDY3,专注于性能
    1：二进制传输
        HTTP1.1文本格式,起始行,首部和实体正文组成,各部分之间以文本换行符分割。
        HTTP2.0将请求和响应分割为更小的帧,并且它们采用二进制编码
        每个数据流都以消息的形式发送,每个消息又由N个帧组成,每个帧之间以乱序发送,根据帧首部的流标识可以重新组装。
        每个请求都可以带一个31Bit的优先值,0表示最高优先级,数值越大优先级越低。优先值高的优先处理。
    2：使用多路复用技术。同一个域名下所有通信在单个连接上完成,避免浏览器限制同一个域名下的请求数据问题。
    3：Header压缩
        客户端和服务端使用"首部表"来跟踪和存储之前发送的键值对,对于相同的数据,不再发送,每次只发送更新的或者新增的键值对。
    4：Server Push
        服务端通过push的技术提前给客户端必要的资源,这样可以减少一点延迟时间.
        如：服务端主动推送JS和CSS文件给客户端,而不需要等到客户端解析HTTP文件后再发送这些请求。
HTTP2.0缺点：
    一个域名下使用一个TCP链接,如果这个连接出现了丢包的情况,
    整个TCP都要等待重传,导致后面的数据被阻塞.导致还不如HTTP1.1
HTTP3.0
    基于UDP协议的QUIC协议


SPDY加快网站速度：在TCP和HTTP之间增加了一个新的层次——SPDY,作为HTTP消息的承载
    1、 向下增强了对TCP联接的管理
    2、 向上可以承载HTTP消息内容的传输,并保持HTTP的语义（命令字,头域）不变
SPDY特性：
    1：降低延迟,使用多路复用多个请求Stream来共享一个TCP连接,降低延迟和提高了带宽利用率
        同个域名下所有通信在单个连接上完成
    2：请求优先级,多路复用会导致关键请求被堵塞,SPDY允许每个请求Stream设置优先级,这样重要的请求会优先得到响应。
    3：header压缩：删除多余的header和压缩header减小包的大小和数量
    4：基于HTTPS的加密协议传输
    5：服务端推送：类似WebSocket都实现了传输fream.
HTTP2.0(SPDY的升级版)
    1：类型SPDY只是不要求基于https的加密传输
    2：使用二进制格式：HTTP1.X的解析是基于文本格式,文本格式存在表现形式的多样性



https： 修复HTTP 1X中 内容明文传输的数据安全性问题
加密套件：身份认证算法, 密匙交互算法(非对称加密),对称加密算法,Hash算法(数据完整性校验)
1：客户端发送第一次握手请求
    1、支持的TSL协议版本
    2、支持的加密套件
    3、随机数：random_C
    4、支持的压缩算法
    5、其余扩展字段
2：服务器接收第一次握手请求,并返回
    1、选择使用的协议版本
    2、选择使用的加密套件
    3、选择的压缩算法
    4、随机数：random_S
    5、证书和公匙
3：客户端进行证书验证,并获取证书公匙
    1、证书CA机构验证
    2、证书有效期验证
    3、证书域名和当前域名匹配验证
4：证书验证通过后,发送握手信息：
    1、生成随机数：Pre-master,并用证书公匙加密
    2、生成协商密匙（后续通信使用对称加密算法的密匙）：random_C + random_S + Pre-master
    3、使用之前通信参数的hash值和其他相关信息生成一段数据message,并使用协商密匙加密
5：服务器解密握手信息：
    1、使用私匙解密获得：Pre-master
    2、生成协商密匙：random_C + random_S + Pre-master
    3、计算之前所有通信参数的hash值,使用协商密匙解密握手信息message,验证数据和密匙的正确性
    4、使用之前通信的参数生成数据并使用协商密匙加密回写客户端
6：握手结束：
    1、客户端计算所有接收参数的hash值,并采用协商密匙解密,验证密匙和数据,验证通过握手结束。
7：加密通信
    使用协商密匙与算法加密通信



